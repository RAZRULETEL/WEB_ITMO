package db

import types.PointCheckResult
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.sql.SQLException
import java.sql.Statement

class DBHandler private constructor() {

    private val connection: Connection = DriverManager.getConnection(
        "$databaseHostPort/$databaseName",
//        System.getenv("HELIOS_DB_LOGIN"),
//        System.getenv("HELIOS_DB_PASS"))
        "LOCAL_DB_LOGIN",
    "LOCAL_DB_PASS")


    init {
        connection.createStatement().executeUpdate("""CREATE TABLE IF NOT EXISTS "results" (
            "id" INT GENERATED BY DEFAULT AS IDENTITY UNIQUE PRIMARY KEY,
            "x" float,
            "y" float,
            "r" float,
            "timestamp" bigint,
            "execution_time" double precision,
            "success" boolean)
        """.trimMargin())
    }


    private val preparedAddResult: PreparedStatement = connection.prepareStatement(SQL_ADD)

    fun getAllResults(): MutableList<PointCheckResult> {
        try {
            val st: Statement = connection.createStatement()
            val res = ArrayList<PointCheckResult>()
            val set = st.executeQuery(SQL_GET_ALL)
            while(set.next()){
                res.add(PointCheckResult(
                    set.getFloat("x"),
                    set.getFloat("y"),
                    set.getFloat("r"),
                    set.getLong("timestamp"),
                    set.getDouble("execution_time"),
                    set.getBoolean("success")
                ))
            }
            return res
        } catch (e: SQLException) {
            e.printStackTrace()
            return ArrayList()
        }
    }

    fun addResult(result: PointCheckResult) {
        try {
            preparedAddResult.setFloat(1, result.x)
            preparedAddResult.setFloat(2, result.y)
            preparedAddResult.setFloat(3, result.r)
            preparedAddResult.setLong(4, result.timestamp)
            preparedAddResult.setDouble(5, result.executionTime)
            preparedAddResult.setBoolean(6, result.success)
            preparedAddResult.executeUpdate()
        } catch (e: SQLException) {
            e.printStackTrace()
        }
    }

    fun clearResults(){
        try {
            connection.createStatement().executeUpdate(SQL_DELETE_ALL)
        } catch (e: SQLException) {
            e.printStackTrace()
        }
    }

    companion object {

        private const val SQL_GET_ALL = "SELECT * FROM results;"
        private const val SQL_ADD = "INSERT INTO results(x, y, r, timestamp, execution_time, success) VALUES(?, ?, ?, ?, ?, ?);"
        private const val SQL_DELETE_ALL = "DELETE FROM results;"

        //    Helios
//    private const val databaseHostPort = "jdbc:postgresql://pg:5432" ;
//    private const val databaseName = "studs";

        //    Local
        private const val databaseHostPort = "jdbc:postgresql://localhost:5433"
        private const val databaseName = "postgres"

        var instance: DBHandler = DBHandler()
            get() {
                if(field.connection.isClosed) field = DBHandler()
                return field
            }
            private set
    }
}