package db

import types.PointCheckResult
import java.net.ConnectException
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.sql.SQLException
import java.sql.Statement

class DBHandler private constructor() {
    private val connection: Connection = DriverManager.getConnection(
        "$databaseHostPort/$databaseName",
        System.getenv("DB_LOGIN"),
        System.getenv("DB_PASS")
    )


    init {
        connection.createStatement().executeUpdate(
            """CREATE TABLE IF NOT EXISTS "results" (
            "id" INT GENERATED BY DEFAULT AS IDENTITY UNIQUE PRIMARY KEY,
            "x" float,
            "y" float,
            "r" float,
            "timestamp" bigint,
            "execution_time" double precision,
            "success" boolean)
        """.trimMargin()
        )
    }

    private val preparedAddResult: PreparedStatement = connection.prepareStatement(SQL_ADD)

    fun getAllResults(): MutableList<PointCheckResult> {
        try {
            val st: Statement = connection.createStatement()
            val res = ArrayList<PointCheckResult>()
            val set = st.executeQuery(SQL_GET_ALL)
            while (set.next()) {
                res.add(
                    PointCheckResult(
                        set.getFloat("x"),
                        set.getFloat("y"),
                        set.getFloat("r"),
                        set.getLong("timestamp"),
                        set.getDouble("execution_time"),
                        set.getBoolean("success")
                    )
                )
            }
            return res
        } catch (e: SQLException) {
            e.printStackTrace()
            return ArrayList()
        } catch (e: ConnectException) {
            e.printStackTrace()
            return ArrayList()
        }
    }

    fun addResult(result: PointCheckResult) {
        try {
            preparedAddResult.setFloat(1, result.x)
            preparedAddResult.setFloat(2, result.y)
            preparedAddResult.setFloat(3, result.r)
            preparedAddResult.setLong(4, result.timestamp)
            preparedAddResult.setDouble(5, result.executionTime)
            preparedAddResult.setBoolean(6, result.success)
            preparedAddResult.executeUpdate()
        } catch (e: SQLException) {
            e.printStackTrace()
        } catch (e: ConnectException) {
            e.printStackTrace()
        }
    }

    fun clearResults() {
        try {
            connection.createStatement().executeUpdate(SQL_DELETE_ALL)
        } catch (e: SQLException) {
            e.printStackTrace()
        } catch (e: ConnectException) {
            e.printStackTrace()
        }
    }

    companion object {

        private const val SQL_GET_ALL = "SELECT * FROM results;"
        private const val SQL_ADD =
            "INSERT INTO results(x, y, r, timestamp, execution_time, success) VALUES(?, ?, ?, ?, ?, ?);"
        private const val SQL_DELETE_ALL = "DELETE FROM results;"

        //    Helios
//    private const val databaseHostPort = "jdbc:postgresql://pg:5432" ;
//    private const val databaseName = "studs";

        //    Local
        private const val databaseHostPort = "jdbc:postgresql://database:5432"
        private const val databaseName = "postgres"

        var instance: DBHandler? = null
            get() {
                if (field == null || field!!.connection.isClosed)
                    try{
                        field = DBHandler()
                    } catch (e: SQLException){
                        System.err.println("DB connection error: ${e.message}")
                    }
                return field
            }
            private set
    }
}